# Parsing

Objectives: FIRST & FOLLOW sets, be able to construct a LL(1) parse table and determine if a grammar is LL(1)

Do top down parsing question in book, use notes for help, check solutions, find videos?

## 4.2 Ambiguity

A grammar that produces one than more parse tree for some sentence is said to be ambiguous

 Verifying a language generated by a grammar

A proof that a grammar G generates a language L has two parts:

1. Show that every string generated by G is in L
2. Show that every string in L can be generated by G

EX: S → (S) S | empty ; language that generates all strings of balanced parentheses

## Eliminating Ambiguity

Sometimes an ambiguous grammar can be rewritten to eliminate ambiguity

stmt → if expr then stmt

| if expr then stmt else stmt

| other

![Untitled](Parsing%2095616a316266401494bb34fc5f30c258/Untitled.png)

The first parse tree is preferred, match each else with the closest then

We can rewrite the grammar with the idea that a statement appearing between a then and else must be matched

stmt → matched_stmt

| open_stmt

matched_stmt → if expr then matched_stmt else matched_stmt

| other

open_stmt → if expr then stmt

| if expr then matched_stmt else open_stmt

## Elimination of Left Recursion

A grammar is left recursive if it has a nonterminal A such that 

A → Aa

Topdown parsers cannot handle left recursion so a transformation is needed

Ex: non-left-recursive expression grammar

E → T E’

E’ → + T E’

T → F T’

T’ → * F T’

F → (E) | id

is obtained by eliminating immediate left recursion from the expression grammar

E → E + T | T

T → T * F | F

F → (E) | id

Immediate left recursion can be eliminated by the following technique, which works for any number of A-productions

First, group the productions as such

A → Aa1 | Aa2 | Aa3 | b1 | b2 | b3

Where no Bi begins with an A. Then replace the A productions with

A → b1A’ | b2A’ etc

A’ → a1A’ | a2A’ | …. anA’ | empty

Basically, find the first A production that doesn’t have A on the leftmost side, and replace A with a production pointing to that production + A’

Repeat & substitute any indirect left recursion

e.g S → a B

B → S A B

becomes

S → a B

B → a B A B

## Left Factoring

Grammar transformation useful for producing a grammar suitable for predictive or top-down parsing

When the choice between two alternative A-productions is not clear, we may be able to rewrite the productions to defer until enough of the input has been seen that we can make the right choice

In general, if we have A → aB1 | aB2 and the input begins with a nonempty string derived from a, we don’t know whether to expand to B1 or B2

However, we can defer the decision by expanding A to aA’

Then, after seeing the input derived from a, we expand A’ to B1 or B2

The original productions become 

A → aA’

A’ → B1 | B20

Method:

For each nonterminal A, find the longest common prefix a common to two or more of its production rules, if a ≠ empty, there is a nontrivial common prefix

Replace all of the A productions A → aB1 | aB2 | aB3 | y where y represents all alternatives that don’t begin with a

with

A → aA’ | y

A’ → B1 | B2 | B3 | Bn

## Top-Down Parsing - RDP, FIRST&FOLLOW, LL(1)

The problem of constructing a parse tree for the input string, starting from the root and creating the nodes of the parse tree in preorder(depth first)

At each step of a top-down parse, the key problem is that of determining the production to be applied for a nonterminal, say A

Once an A-production is chosen, the rest of the parsing process consists of matching the terminal symbols in the production body with the input string

### Recursive Descent Parsing

General recursive descent may require backtracking; that is, it may require repeated scans over the input

A left recursive grammar can cause a recursive descent parser to go into an infinite loop

## FIRST & FOLLOW

During top-down parsing, FIRST and FOLLOW allow us to choose which production to apply, based on the next input symbol

FIRST(a) is the j—————————————————————————————————————————————————————set of terminals that begin strings derived from a. If a→empty, then empty is also a member

Consider two productions, A→ a | b, FIRST(a) and FIRST(b) are disjoint sets

We can then choose between these productions by looking at the next input symbol, say a, as the input symbol cannot be in both a and b since they are disjoint

FOLLOW(A) for nonterminal A, is the set of terminals a that can appear immediately after A in some sentential form

If A can be the rightmost symbol in sentential form, then $(eof) is also in FOLLOW(A)

E → T E’

E’ → + T E’ | empty

T → F T’

T’ → * F T’ | empty

F → (E) | id

FIRST(F) → { (, id }

FIRST(T’) → { *, empty }

FIRST(T) → FIRST(F)

FIRST(E’) → { +, empty}

FIRST(E) → FIRST(T) → FIRST(F)

FOLLOW(E) → { ), $}

FOLLOW(E’) → { FOLLOW(E) } - it only occurs at the end of E-productions, so whatever follows E’ also follows E

FOLLOW(T) → { FOLLOW(E’), FOLLOW(T’), FIRST(E’) } - T only occurs before E’, T’ only occurs at the end of T productions

FOLLOW(T’) → { FOLLOW(T) }

FOLLOW(F) → { +, *, ), $}

### LL(1) Grammars

Predictive parsers(RDP with no backtracking) can be constructed for a class of grammars called LL(1)

Transition diagrams are useful for visualising predictive parsers

To construct the transition diagram for a grammar, first eliminate left recursion and then left factor the grammar

For each nonterminal A 

1. create an initial and final (return) state
2. For each production A → x1x2….xk, create a path from the initial to the final state, with edges labeled x1, x2, xk. If A → empty, the path is also an edge labeled empty

Parsers have one diagram for each nonterminal. The labels of the edges can be tokens or nonterminals. A transition on a token(terminal) means that we take that transition if the token is the next input symbol

A transition on a nonterminal A is a call of the procedure for A

Classifying a grammar as LL(1)

No left-recursive or ambiguous grammar can be LL(1)

A grammar G is LL(1) if and only if whenever A → a | b are two distinct productions of G, the following conditions hold:

1. For no terminal a do both a and b derive strings beginning with a
2. At most one of a and b can derive the empty string
3.  If b → empty, then a does not derive any string beginning with a terminal in FOLLOW(A)

In clear terms

FIRST(a) and FIRST(b) are disjoint sets

If empty is in FIRST(b), then FIRST(a) and FOLLOW(a) are disjoint sets, and likewise if empty is in FIRST(a)

Predictive Parsers can be constructed for LL(1) grammars since the production to apply for a nonterminal can be selected by looking at only the current symbol

We collect the information from the first and follow sets and construct a predictive parsing table M[A, a], a two-dimensional array where A is a nonterminal and a is a terminal or the symbol $

It is based on the following idea:

The production A → a is chosen if the next input symbol a is in first(a)

The only complication occurs when a = empty or more generally some repetitive rule application leads from a to empty

We should again choose A → a if the current input symbol is in FOLLOW(a) or if the $ symbol has been reached and $ is in FOLLOW(A)

## Construction of Predictive Parsing Table

For each production A → a of the grammar, do the following:

1. For each terminal a in FIRST(A), add A → a to M[A, a]
2. If empty in FIRST(a), then for each terminal b in FOLLOW(A), add A → a to M[A, b], if empty in FIRST(a) and $ is in FOLLOW(A), add A → a to M[A, $] as well

If, after performing the above, there is no production at all in M[A, a], then set M[A, a] to error (which we normally represent with an empty entry in the table)

For every LL(1) grammar, each parsing table entry uniquely identifies a production or signals an error

For some grammars, M may have some entries that are multiply defined. For example, if G is left-recursive or ambiguous, then M will have at least one multiply defined entry

Although left recursion elimination and left factoring are easy to do, there are some grammars for which no amount of alteration will produce a LL(1) grammar

## Non-recursive Predictive Parsing

Can be built by maintaining a stack explicitly, rather than implicitly via recursive calls

The parser mimics a leftmost derivation. If w is the input that has been matched so far, then the stack holds a sequence of grammar symbols a such that

S →… wa

(→… means repeated production applications)

A table-driven parser has an input buffer, a stack containing a sequence of grammar symbols, a parsing table constructed by the previous algorithm for constructing a predictive parsing table and an output stream

The input buffer contains the string to be parsed, followed by the endmarker $

We reuse $ to mark the bottom of the stack, which initially contains the start symbol of the grammar on top of $

The parser is controlled by a program that considers X, the symbol on top of the stack, and a, the current input symbol

If X is a nonterminal, the parser chooses an X-production by consulting entry M[A,a] of the parsing table

If X is a terminal, it checks for a match between X and a

## Table-Driven(non-recursive) Predictive Parsing Algorithm

Input: a string w and a parsing table M for grammar G

![Untitled](Parsing%2095616a316266401494bb34fc5f30c258/Untitled%201.png)

Initially, the parser is in configuration with w$ in the input buffer and the start symbol S of G on top of the stack, above $

The program uses the predictive parsing table M to produce a predictive parse for the input

```python
pseudocode

set ip to point to the first symbol of w;
set X to the top stack symbol;
while ( X /= $)
		if (X is a) pop the stack and advance ip;
		else if (X is a terminal) error();
		else if (M[X, a] is an error entry) error();
		else if (M[X, a] = X -> Y1, Y2...Yk) {
				output the production X -> Y1, Y2...Yk;
				pop the stack
				Push Yk,Yk-1....Y1 onto the stack, with Y1 on top;
		}
		set X to the top stack symbol;

```