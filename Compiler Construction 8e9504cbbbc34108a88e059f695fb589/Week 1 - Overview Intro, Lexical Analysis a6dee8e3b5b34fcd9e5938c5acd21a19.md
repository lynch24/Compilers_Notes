# Week 1 - Overview / Intro, Lexical Analysis

Structure of a compiler

Lexical analysis

Parsing

Abstract syntax

Semantic analysis

Intermediate code generation

Register Allocation & Code Optimisation

Run-time environments

Code generation

30% CA

### What is a compiler vs Interpreter?

A compiler is a program that translates an executable program in one language into a executable program in another language

An interpreter reads an executable program and produces the results of running that program

This involves evaluating the source program

Many of the same frontend issues arise in interpreters and compilers

### Overview of the Compilation Process

The compilation process consists of a number of phases. The number of phases varies from compiler to compiler depending on their complexity

A basic set of phases are:

Lexical Analysis

Syntax Analysis

Semantic Analysis

Intermediate Code Analysis

Code Optimisation

Code Generation

The first three phases comprise the frontend of the compiler

The second three phases comprise the backend of the compiler

### Lexical Analysis - The isolation of tokens

The goal of lexical analysis is to convert a stream of characters from the source program into a stream of tokens that represent recognised keywords, identifiers, numbers and punctuation

Some tokens, such as identifiers and numbers, require an additional quality, called a lexeme, that indicates type and/or value of the token

### Syntax Analysis - The Combination of tokens into sentences

The goal of syntax analysis is to combine the tokens generated by the lexical analysis into a valid sentence

A grammar is a set of rules that specifies how the tokens can be combined

EX: answer = x * 2 - y

Let’s assume the following grammar:

goal → assignment | exp

assignment → id ‘=’ exp

exp → id | num | mul | add | subtract

mul → exp * exp

add → exp + exp

subtract → exp - exp

![Untitled](Week%201%20-%20Overview%20Intro,%20Lexical%20Analysis%20a6dee8e3b5b34fcd9e5938c5acd21a19/Untitled.png)

![Untitled](Week%201%20-%20Overview%20Intro,%20Lexical%20Analysis%20a6dee8e3b5b34fcd9e5938c5acd21a19/Untitled%201.png)

The Abstract Syntax Tree is a compressed version of the Parse Tree, but without the redundant information

### Semantic Analysis - Semantic Error Check and Typing

In a compiler, this phase checks the source program for semantic errors, and gathers type information for the intermediate code generation

For example, what if answer and y are integers and x is a float?

In an interpreter, this phase evaluates the source program stored in the AST

### Intermediate Code Generation - Intermediate translation into machine or assembly

A kind of abstract machine code which does not rely on a particular target machine by specifying the registers or memory locations to be used for each operation

This separates into a mostly language dependent frontend and a mostly machine dependent backend

For example: 

![Untitled](Week%201%20-%20Overview%20Intro,%20Lexical%20Analysis%20a6dee8e3b5b34fcd9e5938c5acd21a19/Untitled%202.png)

### Code Generation

This is an optional phase which can be used to improve the intermediate code to make it run faster and/or use less memory

For example, the variable temp in the previous fragment of intermediate code is not required. This can be removed to give the following

![Untitled](Week%201%20-%20Overview%20Intro,%20Lexical%20Analysis%20a6dee8e3b5b34fcd9e5938c5acd21a19/Untitled%203.png)

This phase translates intermediate code into object code, allocating memory locations for data, and selecting registers

This can also include a linking phase when the language allows the source code to be written in separate files

[Lexical Analysis](Week%201%20-%20Overview%20Intro,%20Lexical%20Analysis%20a6dee8e3b5b34fcd9e5938c5acd21a19/Lexical%20Analysis%208cc333d1d9634a22bead9e8354992f74.md)